---
title: "HRIMC_tonsil_nuclear_masks"
author: "James Whipman & Alina Bollhagen"
date: "2025-03-17"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Introduction
This script merges two TMA acquisitions (the Zürich cohort and the Basel matched TMA). It generates
sce objects and carries out spillover correction. Requires metadata and spillover matrix. 

```{r read in packages}
library(RANN)  
library(SingleCellExperiment)
library(ggplot2)
library(ggpubr)
library(cytomapper)
library(cytoviewer)
library(reshape2)
```

```{r Read in the necessary data}
input_folder <- "/mnt/central_nas/projects/Pladioc/SRIMC_project/Zenodo/Figure_2/Nuclear_masks/"
cells <- read.csv(file = paste0(input_folder, "objects.csv"), stringsAsFactors = FALSE)
panel <- read.csv(file = paste0(input_folder, "panel.csv"), stringsAsFactors = FALSE)
```

```{r meta data: cell objects}
# Add rownames (combination of image number and object number)
rownames(cells) <- paste0(cells$Image, "_", cells$Object)
cell_meta <- data.frame(CellNumber = cells$Object,
                       Center_X = cells$centroid.0,
                       Center_Y = cells$centroid.1,
                       Area = cells$area,
                       MajorAxisLength = cells$axis_major_length,
                       MinorAxisLength = cells$axis_minor_length, 
                       image = factor(cells$Image),
                       row.names = paste0(cells$Image, "_", cells$Object))

# check whether the order is the same
all.equal(rownames(cell_meta), rownames(cells))
cell_meta_classic <- as.data.frame(cell_meta)
cell_meta_classic$resolution <- "Classical"
colnames(cells)[c(3:5,7:36)] <- c("MPO", "H3", "CD11c", "ECAD","CCR7","VIM", "HLADR","CD4","SMA","CD11b","CD20","CD56","Decorin","CD3","DC_LAMP","ATP5A","Periostin","H3K27me2","HSP10","CD8","CD45", "FOXP3","CD68","Ki-67","CD8_b","FOXP3_b","IRF4","CD4","CD31","CXCL12","DNA1","DNA2","CD15")
#Filter markers with signal
cells_classic <- cells[, -c(1:2,5:6,11,16,20:21,28:30,33,37:42)]
```

```{r Input matched TMA}
sce_classic <- SingleCellExperiment(assays = list(counts = t(cells_classic)))
rownames(sce_classic) <- colnames(cells_classic)
colnames(sce_classic) <- rownames(cells_classic)
colData(sce_classic) <- DataFrame(cell_meta_classic)
```


```{r spillover correction}

assay(sce_classic, "exprs") <- asinh(assay(sce_classic, "counts"))
assay(sce_classic, "scaled") <- t(scale(t(assay(sce_classic, "exprs"))))

cell_norm_counts <- t(apply(assay(sce_classic, "counts"), 1, function(x)(x-min(x))/(quantile(x, 0.99)-min(x))))
cell_norm_counts <- t(apply(cell_norm_counts, 1, function(x) pmin(x, 1)))


counts <- lapply(unique(sce_classic$image), function(x) {
          cell_norm_counts <- t(apply(assay(sce_classic[,sce_classic$image == x], "counts"), 1, function(x)(x-min(x))/(quantile(x, 0.99)-min(x))))
          cell_norm_counts <- apply(cell_norm_counts, 1, function(x) pmin(x, 1))
        })

assay(sce_classic, "normalized", withDimnames = FALSE) <- t(do.call(rbind, counts))
```

```{r Input matched TMA}
sce_classic <- SingleCellExperiment(assays = list(counts = t(cells_classic)))
rownames(sce_classic) <- colnames(cells_classic)
colnames(sce_classic) <- rownames(cells_classic)
colData(sce_classic) <- DataFrame(cell_meta_classic)
```

```{r}
sce_hr <- sce_classic[,which(sce_classic$image == "Tonsil_333nm_processed.tiff")]
sce_classic <- sce_classic[,which(sce_classic$image != "Tonsil_333nm_processed.tiff")]

#deconvolution removes three pixels
sce_classic$Center_X <- sce_classic$Center_X -3
sce_classic$Center_Y <- sce_classic$Center_Y -3

```


```{r detecting merged nuclei}
coords_high_res <- data.frame(x= (sce_hr$Center_X), y = (sce_hr$Center_Y))
rownames(coords_high_res) <- colnames(sce_hr)
coords_classic <- data.frame(x= (sce_classic$Center_X) , y = (sce_classic$Center_Y))
rownames(coords_classic) <- colnames(sce_classic)
#Select the nearest cell but make sure it's not further away than the mean diameter.


#For classic IMC
nearest <- nn2(data = coords_classic, query = coords_high_res, k = 1)
nearest_indices <- nearest$nn.idx[, 1]

coords_classic$diameter <- sce_classic$MajorAxisLength
distances <- sqrt((coords_high_res$x - coords_classic$x[nearest_indices])^2 +
                  (coords_high_res$y - coords_classic$y[nearest_indices])^2)

diameters <- coords_classic$diameter[nearest_indices]
sce_hr$nearest_classic <- rownames(coords_classic)[nearest_indices]
Missing <- sce_hr$nearest_classic[distances > diameters]

merged_cells <- table(sce_hr$nearest_classic)
sce_classic$merged <- "Matched"
sce_classic$merged[colnames(sce_classic) %in% names(merged_cells[merged_cells > 1])] <- "Merged"
sce_classic$merged[colnames(sce_classic) %in% Missing] <- "Extra"




coords_high_res <- data.frame(x= (sce_hr$Center_X), y = (sce_hr$Center_Y))
rownames(coords_high_res) <- colnames(sce_hr)
coords_classic <- data.frame(x= sce_classic$Center_X, y = sce_classic$Center_Y)
rownames(coords_classic) <- colnames(sce_classic)

## For hiRes IMC
nearest <- nn2(data = coords_high_res, query = coords_classic, k = 1)
nearest_indices <- nearest$nn.idx[, 1]
coords_high_res$diameter <- sce_hr$MajorAxisLength
distances <- sqrt((coords_classic$x - coords_high_res$x[nearest_indices])^2 +
                  (coords_classic$y - coords_high_res$y[nearest_indices])^2)
diameters <- coords_high_res$diameter[nearest_indices]

sce_classic$nearest_hr <- rownames(coords_high_res)[nearest_indices]
Missing <- sce_classic$nearest_hr[distances > diameters]

merged_cells <- table(sce_classic$nearest_hr)
sce_hr$merged <- "Matched"
sce_hr$merged[colnames(sce_hr) %in% names(merged_cells[merged_cells > 1])] <- "Merged"
sce_hr$merged[colnames(sce_hr) %in% Missing] <- "Extra"


duplicates <- names(table(sce_classic$nearest_hr)[table(sce_classic$nearest_hr) > 1])
sce_classic$merged[sce_classic$nearest_hr %in% duplicates] <- "Split"

duplicates <- names(table(sce_hr$nearest_classic)[table(sce_hr$nearest_classic) > 1])
sce_hr$merged[sce_hr$nearest_classic %in% duplicates] <- "Split"

```


```{r}
data_hr <- as.data.frame(table(sce_hr$merged))
data_classic <- as.data.frame(table(sce_classic$merged))

# Define the colors
colors <- c("Split" = "#ba7e7e", "Merged" = "#e7c28e", "Matched" = "#4D4D4D")

# Create the stacked bar plot
ggplot(data_hr, aes(x = "", y = Freq, fill = Var1)) +
  geom_bar(stat = "identity", width = 1) +
  scale_fill_manual(values = colors) +# Flip for horizontal bars
  labs(x = NULL, y = "Count", fill = "Category") +
  theme_minimal()

ggplot(data_classic, aes(x = "", y = Freq, fill = Var1)) +
  geom_bar(stat = "identity", width = 1) +
  scale_fill_manual(values = colors)# Flip for horizontal bars
  labs(x = NULL, y = "Count", fill = "Category") +
  theme_minimal()
```


## Comparison of nuclear masks

```{r}
path.to.masks <- "/mnt/central_nas/projects/Pladioc/SRIMC_project/Zenodo/Figure_2/Nuclear_masks/masks/"
path.to.images <- "/mnt/central_nas/projects/Pladioc/SRIMC_project/Zenodo/Figure_2/Nuclear_masks/img/"
panel <- read.csv("/mnt/central_nas/projects/Pladioc/SRIMC_project/Zenodo/Figure_2/Nuclear_masks/panel.csv")
selected_images <- unique(sce_classic$image)
masks <- loadImages(path.to.masks, pattern = paste(selected_images, collapse = "|"), as.is = TRUE)
images <- loadImages(path.to.images, pattern = paste(selected_images, collapse = "|"))


channelNames(images) <-panel$name
images_new <- getChannels(images, c(1,2,5:8,10:13,15:17,20:25,29,30,32:34)) 
images_new <- scaleImages(images_new, 2^16-1)
channelNames(images_new) <- rownames(sce_classic)

#sce_classic$image <- sub(".tiff", "", sce_classic$image)
mcols(images_new)$image <- unique(sce_classic$image)
mcols(masks)$image <- unique(sce_classic$image)

app <- cytoviewer(image = images_new, 
                  mask = masks, 
                  object = sce_classic, 
                  img_id = "image", 
                  cell_id = "CellNumber")

if (interactive()) {
  shiny::runApp(app)
}
```



```{r}
path.to.masks <- "/mnt/central_nas/projects/Pladioc/SRIMC_project/Zenodo/Figure_2/Nuclear_masks/masks/"
path.to.images <- "/mnt/central_nas/projects/Pladioc/SRIMC_project/Zenodo/Figure_2/Nuclear_masks/img/"

selected_images <- unique(sce_hr$image)
masks <- loadImages(path.to.masks, pattern = paste(selected_images, collapse = "|"), as.is = TRUE)
images <- loadImages(path.to.images, pattern = paste(selected_images, collapse = "|"))


channelNames(images) <-panel$name
images_new <- getChannels(images, c(1,2,5:8,10:13,15:17,20:25,29,30,32:34)) 
images_new <- scaleImages(images_new, 2^16-1)
channelNames(images_new) <- rownames(sce_hr)

sce_hr$image <- sub(".tiff", "", sce_hr$image)
mcols(images_new)$image <- unique(sce_hr$image)
mcols(masks)$image <- unique(sce_hr$image)

app <- cytoviewer(image = images_new, 
                  mask = masks, 
                  object = sce_hr, 
                  img_id = "image", 
                  cell_id = "CellNumber")

if (interactive()) {
  shiny::runApp(app)
}
```


#Comparison to QUPATH segmentation
To compare to "ground truth", we segment the H&E high resolution image and 
match cells. We have to transform the coordinates first and only take overlapping
areas.

```{r  Comparison to QuPath segmentation}
cells <- read.csv("/mnt/central_nas/projects/Pladioc/SRIMC_project/Zenodo/Figure_2/Nuclear_masks/HE_staining/segmentation.csv", stringsAsFactors = FALSE)
transformation_matrix <- as.matrix(read.table("/mnt/central_nas/projects/Pladioc/SRIMC_project/Zenodo/Figure_2/Nuclear_masks/HE_staining/HE_transformation_matrix.txt", sep = ","))
```


```{r alignment}
#Multiply by image pixels per micron (transformation done on pixel level and measurements output on micron level)
cells$Centroid.X.µm <- cells$Centroid.X.µm* 11.49
cells$Centroid.Y.µm <- cells$Centroid.Y.µm* 11.49

#Multiply by image pixels per micron (subtract the origin as alignment done on annotation and output coords on whole image)
cells$Centroid.X.µm <- cells$Centroid.X.µm - 1196*11.49
cells$Centroid.Y.µm <- cells$Centroid.Y.µm - 973* 11.49

#Apply the transformation matrix
coords <- as.matrix(cbind(cells$Centroid.X.µm, cells$Centroid.Y.µm, 1))
transformed_coords <- coords %*% as.matrix(t(transformation_matrix))
transformed_coords <- as.data.frame(transformed_coords)

cells$Centroid.X.µm <- transformed_coords$V1
cells$Centroid.Y.µm <- transformed_coords$V2
```

To understand whether there is a regional effect of nuclear merging, we select different regions of the image.
Inspection shows the presence the germinal center in part of the image which could skew the number of merged cells if they are more tightly packed. To test this, we split the image into four zones. 

```{r}
x_mid <- median(sce_hr$Center_X)
y_mid <- median(sce_hr$Center_Y)

quadrant <- ifelse(sce_hr$Center_X <= x_mid & sce_hr$Center_Y <= y_mid, "Q1",
            ifelse(sce_hr$Center_X >  x_mid & sce_hr$Center_Y <= y_mid, "Q2",
            ifelse(sce_hr$Center_X <= x_mid & sce_hr$Center_Y >  y_mid, "Q3", "Q4")))
sce_hr$quadrant <- factor(quadrant)

x_mid <- median(sce_classic$Center_X)
y_mid <- median(sce_classic$Center_Y)

quadrant <- ifelse(sce_classic$Center_X <= x_mid & sce_classic$Center_Y <= y_mid, "Q1",
            ifelse(sce_classic$Center_X >  x_mid & sce_classic$Center_Y <= y_mid, "Q2",
            ifelse(sce_classic$Center_X <= x_mid & sce_classic$Center_Y >  y_mid, "Q3", "Q4")))
sce_classic$quadrant <- factor(quadrant)

x_mid <- median(cells$Centroid.X.µm)
y_mid <- median(cells$Centroid.Y.µm)

quadrant <- ifelse(cells$Centroid.X.µm <= x_mid & cells$Centroid.Y.µm <= y_mid, "Q1",
            ifelse(cells$Centroid.X.µm >  x_mid & cells$Centroid.Y.µm <= y_mid, "Q2",
            ifelse(cells$Centroid.X.µm <= x_mid & cells$Centroid.Y.µm >  y_mid, "Q3", "Q4")))
cells$quadrant <- factor(quadrant)
```


```{r matching cells}
#Need to find the overlap (vast majority of IMC is contained within HE)
set.seed(18987)
set1 <- data.frame(x = cells$Centroid.X.µm, y = cells$Centroid.Y.µm)
set2 <- data.frame(x =sce_hr$Center_X, y = sce_hr$Center_Y)
set3 <- data.frame(x =sce_classic$Center_X, y = sce_classic$Center_Y)

#cells overlap in high res compared to HE
nn1 <- nn2(set2, set1, k = 1)
dist1 <- nn1$nn.dists[, 1]

#H&E vs high res overlap
nn2 <- nn2(set1, set2, k = 1)
dist2 <- nn2$nn.dists[, 1]

#cells overlap H&E vs convolved
nn3 <- nn2(set1, set3, k = 1)
dist3 <- nn3$nn.dists[, 1]

# Keep only points present in both filtered sets
filtered_set1 <- set1[dist1 <= 30, ]
filtered_set2 <- set2[dist2 <= 30, ]
filtered_set3 <- set3[dist3 <= 30, ]

cells <- cells[as.numeric(rownames(filtered_set1)),]
sce_hr <- sce_hr[,as.numeric(rownames(filtered_set2))]
sce_classic <- sce_classic[,as.numeric(rownames(filtered_set3))]
```

```{r amount of matching cells}
coords_high_res <- data.frame(x= (sce_hr$Center_X), y = (sce_hr$Center_Y))
rownames(coords_high_res) <- colnames(sce_hr)

coords_classic <- data.frame(x= (sce_classic$Center_X) , y = (sce_classic$Center_Y))
rownames(coords_classic) <- colnames(sce_classic)

coords_HE <- data.frame(x = cells$Centroid.X.µm, y = cells$Centroid.Y.µm)
rownames(coords_HE) <- rownames(cells)
#Select the nearest cell but make sure it's not further away than the mean diameter.

#For classic IMC
nearest <- nn2(data = coords_classic, query = coords_HE, k = 1)
nearest_indices <- nearest$nn.idx[, 1]

coords_classic$diameter <- sce_classic$MajorAxisLength
distances <- sqrt((coords_HE$x - coords_classic$x[nearest_indices])^2 +
                  (coords_HE$y - coords_classic$y[nearest_indices])^2)

diameters <- coords_classic$diameter[nearest_indices]
cells$nearest_classic <- rownames(coords_classic)[nearest_indices]
Missing <- cells$nearest_classic[distances > diameters]

merged_cells <- table(cells$nearest_classic)
sce_classic$merged <- "Matched"
sce_classic$merged[colnames(sce_classic) %in% names(merged_cells[merged_cells > 1])] <- "Merged"
sce_classic$merged[colnames(sce_classic) %in% Missing] <- "Extra"

table(sce_classic$merged)

#For highRES
nearest <- nn2(data = coords_high_res, query = coords_HE, k = 1)
nearest_indices <- nearest$nn.idx[, 1]
coords_high_res$diameter <- sce_hr$MajorAxisLength
distances <- sqrt((coords_HE$x - coords_high_res$x[nearest_indices])^2 +
                  (coords_HE$y - coords_high_res$y[nearest_indices])^2)
diameters <- coords_high_res$diameter[nearest_indices]

cells$nearest_hr <- rownames(coords_high_res)[nearest_indices]

Missing <- cells$nearest_hr[distances > diameters]
merged_cells <- table(cells$nearest_hr)
sce_hr$merged <- "Matched"
sce_hr$merged[colnames(sce_hr) %in% names(merged_cells[merged_cells > 1])] <- "Merged"
sce_hr$merged[colnames(sce_hr) %in% Missing] <- "Extra"
```


```{r matching cells}
sce_hr$merged[sce_hr$merged %in% c("Merged", "Extra")] <- "Unmatched"
sce_classic$merged[sce_classic$merged %in% c("Merged", "Extra")] <- "Unmatched"
data <- t(rbind(unclass(prop.table((table(sce_hr$merged, sce_hr$quadrant)), margin = 2))[2,], unclass(prop.table((table(sce_classic$merged, sce_classic$quadrant)), margin = 2))[2,]))
colnames(data) <- c("HR-IMC", "Classic IMC")
data <- melt(data)
print(data)

ggplot(data, aes(x = Var2, y = value, fill = Var2)) +
  geom_bar(stat = "summary", fun = mean, width = 0.6) +
  geom_errorbar(stat = "summary", fun.data = mean_se, width = 0.2) +
  geom_jitter(width = 0, size = 2, alpha = 0.6) +  
  geom_line(aes(group = Var1), color = "gray50", alpha = 0.2) + 
  stat_compare_means(method = "t.test", paired = TRUE, comparisons = list(c("Classic IMC", "HR-IMC")),
label = "value") + 
  scale_fill_manual(values = c("#e7c28e", "#D7D7D7")) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(y = expression("Proportion of unmatched cells"),x = "Imaging technique")
```

```{r Total number of cells}
data <- t(rbind(unclass(table(cells$quadrant)), unclass(table(sce_hr$quadrant)), unclass(table(sce_classic$quadrant))))
colnames(data) <- c("H&E", "HR-IMC", "Classic IMC")
data <- melt(data)

ggplot(data, aes(x = Var2, y = value, fill = Var2)) +
  geom_bar(stat = "summary", fun = mean, width = 0.6) +
  geom_errorbar(stat = "summary", fun.data = mean_se, width = 0.2) +
  geom_jitter(width = 0.1, size = 3, alpha = 0.6)+
  geom_line(aes(group = Var1), color = "gray80", alpha = 0.2) + 
  scale_fill_manual(values = c("#e7c28e", "#D7D7D7", "grey")) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(y = expression("Total number of cells"),x = "Imaging technique")
```

